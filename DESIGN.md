Technically to implement our project, we used HTML, Python, Javascript, SQL, and Jinja along with some of the scaffolding from the Finance Pset. Our files consist of applications.py and helpers.py which contains the Python code for our website, various HTML templates in a /templates folder, a styles.css file stored in /static to specify styles, and the database, courses50.db, of courses and user information.

1. The `Test` portion of our website randomly selects four course ids from the `courses` table in our courses50 database. However, the maximum course id number, 15426, is larger than the actual number of courses that are in the database. Thus, we could not just randomly generate a number between 1 and 15426 to then pass that through the HTML page, because if no course exists for the id our test would display anywhere from 0 to 4 options. To navigate this difficulty, we implemented a `while loop` that continuously generates integers between 1 and 15426; however, we break this loop with an 'if statement' once the random number generator generates four course ids that belong to existing courses.

2. We wanted our test to gather 15 classes from the user before providing a concentration suggestion. In order to ensure that we received 15 classes, we implemented a counter. This counter, defined as a global variable increments every time the test page's request method is POST. Thus everytime the page reloads from the user inputted data, i.e. after they answer the previous question, we add one to the counter. This continues while the counter is less than 15. However, to add our fifth option of 'I absolutely despise all of these options!' without adding it to the counter, we have that option submit NULL which then does not increment the counter when POST is called. Thus, the user can proceed wit the test without having that fifth option count as an answer to the test.

3. We implemented a mode function that calculates your suggested concentration. This mode function is passed through all of the departments for each class you chose throughout the test and determines the highest occuring department. In our function, we count the list and verify that the list contains items, i.e. that the user has taken the test once. Then, we select the max of all of the values in our counter, or the department that had been chosen the most. Thus to determine the suggested `concentration,` we pass through the mode function our `departmentsliked` list and take the first element in that array.

4. We got our pie chart for the /results page from Google's API at https://developers.google.com/chart/interactive/docs/gallery/piechart, as we realised doing our own implementation would be a bit too tough, and that this would be more visually rewarding and allow the user to see the suggestions more holistically than if we outputted a simple ordered list. This was one of the tougher parts of our coding - we attempted to mix jinja2 with Javascript in order to pass in to the API the dict of key/value pairs outputted by Python's Counter function, but ultimately realised we should keep the templating language as separate as possible from Javascript, and that trying to get all the languages Python/Javascript/Jinja to talk to each other was not going to be as simple as a jinja2 for loop. Hence we ultimately passed the variable `suggestions` through json.dumps in Python, turning it into a JSON formatted string, and then passed this into metadata in the result.html template, passing that into a Javascript variable called `chartdata`, and finally turned it into an array of arrays, `piedata`, properly formatted for the Google pie chart API.

5. For starring specific courses, we initially wanted to implement it all within /history and just have a button that one can click to star and it saves it directly on the page, much like Gmail's functionality. However, we realised that the implementation of such a feature would be unnecessarily complex and involve AJAX, whereas 1) we had the infrastructure to just return POST requests and do SQL queries and 2) it might even be more effective if the user had a separate list of starred courses rather than trying to implement everything on one /history page. Hence we implemented it so that once the user clicks `STAR`/`UNSTAR`, a POST request returns with the id of the course to star, which looks up whether it is starred (`starlookup`) and does the appropriate action through turning the `starlookup` into an integer we called `starboolean` - 1 if starred, 0 if unstarred. Then, whenever a user executes any starring action, they are taken to the /star page where they can see all their currently starred courses. In /history, we also used a SQL query to find whether the specific course was starred, and using Jinja2's 'if' statements, altered the text on the table to read either `STAR` or `UNSTAR` accordingly.
